<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sopa de Letras Multijugador</title>
  <style>
    /* [Mantengo todo tu CSS existente sin cambios] */
    :root{
      --bg:#0f172a;
      --panel:#111827;
      --card:#1f2937;
      --acc:#3b82f6;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --border:#374151;
    }

    body{
      margin:0;
      background:linear-gradient(120deg,#0b132b,#1c2541);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial;
    }

    .page{
      max-width:1100px;
      margin:24px auto;
      padding:0 16px;
    }

    .header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-bottom:16px;
    }
    .title{
      font-size:clamp(20px,2.5vw,28px);
      font-weight:800;
      letter-spacing:.3px;
    }
    .pill{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
    }

    .layout{
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:16px;
    }

    .card{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(6px);
      border-radius:16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }

    /* Estilos espec√≠ficos de la sopa de letras */
    header {
      text-align: center;
      margin-bottom: 20px;
    }
    
    .wrap {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .game {
      display: grid;
      grid-template-columns: 1fr 250px;
      gap: 16px;
    }
    
    .panel {
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 12px;
      padding: 14px;
      margin-bottom: 16px;
    }
    
    .status.panel {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    
    .small {
      font-size: 12px;
      color: var(--muted);
    }
    
    .badge {
      background: #e5e7eb;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      color: #111827;
    }
    
    .board {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 4px;
      margin-bottom: 12px;
    }
    
    .cell {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-weight: 700;
      cursor: pointer;
      user-select: none;
    }
    
    .cell:hover {
      background: rgba(59, 130, 246, 0.1);
    }
    
    .cell.selected {
      background: rgba(59, 130, 246, 0.3);
    }
    
    .cell.found {
      background: rgba(34, 197, 94, 0.2);
      border-color: rgba(34, 197, 94, 0.5);
    }
    
    .controls {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    
    button {
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      cursor: pointer;
      font-weight: 600;
    }
    
    button.primary {
      background: linear-gradient(180deg,#2563eb,#1d4ed8);
      border-color: #1d4ed8;
      font-weight: 700;
    }
    
    .message {
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 12px;
      text-align: center;
      font-weight: 600;
    }
    
    .message.win {
      background: rgba(34, 197, 94, 0.1);
      color: #86efac;
    }
    
    .message.lose {
      background: rgba(239, 68, 68, 0.1);
      color: #fca5a5;
    }
    
    .clues {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .clues li {
      padding: 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
    }
    
    .clues li.done {
      opacity: 0.6;
      text-decoration: line-through;
    }
    
    .clues .word {
      font-weight: 700;
      margin-bottom: 4px;
    }
    
    .clues .hint {
      font-size: 12px;
      color: var(--muted);
    }

    /* Estilos del chat */
    #chatBox {
      height: 220px;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      background: #0b1023;
      margin-bottom: 10px;
    }
    
    .msg {
      margin-bottom: 6px;
      line-height: 1.25;
    }
    
    .msg .u {
      color: #93c5fd;
      font-weight: 700;
      margin-right: 6px;
    }
    
    .chat-input {
      display: flex;
      gap: 8px;
    }
    
    .chat-input input {
      flex: 1;
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 10px;
      outline: none;
    }
    
    .chat-input input:focus {
      border-color: var(--acc);
    }
    
    .chat-send {
      background: #3b82f6;
      border-color: #2563eb;
      font-weight: 800;
      cursor: pointer;
    }

    /* Estilos para modo enfrentamiento */
    #vista-enfrentamiento {
      display: none;
      grid-template-columns: 1fr 300px 1fr;
      gap: 16px;
    }
    
    .game-enfrentamiento {
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 16px;
      padding: 16px;
    }
    
    .game-enfrentamiento h2 {
      text-align: center;
      margin-top: 0;
      margin-bottom: 12px;
    }
    
    .timer-container {
      text-align: center;
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 16px;
      padding: 8px;
      background: rgba(255,255,255,.06);
      border-radius: 8px;
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
      }
      
      .game {
        grid-template-columns: 1fr;
      }
      
      #vista-enfrentamiento {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="header">
      <div class="title">üß© Sopa de Letras Multijugador</div>
      <div class="pill">
        Jugador: <strong>{{#if user}}{{user.username}}{{else}}Invitado{{/if}}</strong>
      </div>
      <button onclick="location.href='/minijuegos'" style="margin-left: 20px;"> ‚Üê Regresar</button>
    </div>

    {{!-- VISTA 1: MODO COOPERATIVO --}}
    <div id="vista-cooperativo">
      <section class="game card">
        <div>
          <div class="status panel">
            <div>
              <div class="small">Progreso</div>
              <div id="progressText"><strong>0</strong>/<strong id="totalWords">0</strong> palabras</div>
            </div>
            <div class="badge" id="errorsBadge">0 / 4</div>
          </div>
          
          <div class="controls">
            <label for="categoria-select">Categor√≠a:</label>
            <select id="categoria-select">
              <option>Cargando categor√≠as...</option>
            </select>
            <button id="btnClear">Limpiar selecci√≥n</button>
            <button id="btnRestart" class="primary">Reiniciar</button>
          </div>
          
          <div id="board" class="board" aria-label="Tablero de sopa de letras"></div>
          <div id="gameMessage" class="message" role="status" aria-live="polite"></div>
        </div>

        <aside>
          <div class="panel">
            <h3>Palabras a encontrar</h3>
            <ul id="clues" class="clues"></ul>
          </div>
          <div class="panel">
            <h3>Instrucciones</h3>
            <div class="small">
              ‚Ä¢ Arrastra el mouse en recta horizontal o vertical.<br>
              ‚Ä¢ Si no coincide con ninguna palabra, cuenta como error.<br>
              ‚Ä¢ Con <strong>4 errores</strong> pierdes y el juego se reinicia.
            </div>
          </div>
        </aside>
      </section>

      <aside class="side">
        <div class="panel card" id="jugadores-panel">
          <h3>üü¢ Jugadores activos</h3>
          <ul id="lista-jugadores"></ul>
        </div>

        <div class="panel card" id="chat-panel">
          <h3>üí¨ Chat</h3>
          <div id="chatBox"></div>
          <div class="chat-input">
            <input id="chatInput" type="text" placeholder="Escribe un mensaje‚Ä¶">
            <button id="chatBtn" class="chat-send">Enviar</button>
          </div>
        </div>
      </aside>
    </div>

    {{!-- VISTA 2: MODO ENFRENTAMIENTO --}}
    <div id="vista-enfrentamiento">
      {{!-- Panel del Jugador Local (Izquierda) --}}
      <section class="game-enfrentamiento card">
        <h2 id="nombre-local">{{user.username}}</h2>
        <div class="status panel">
          <div>
            <div class="small">Progreso</div>
            <div id="progressText-local"><strong>0</strong>/<strong id="totalWords-local">0</strong> palabras</div>
          </div>
          <div class="badge" id="errorsBadge-local">0 / 4</div>
        </div>
        <div id="board-local" class="board"></div>
        <div id="message-local" class="message"></div>
        <ul id="clues-local" class="clues"></ul>
      </section>
      
      {{!-- Panel Central (Timer, Jugadores, Chat) --}}
      <aside class="side" id="panel-central-enfrentamiento">
        <div class="timer-container">
          Tiempo: <span id="timer">05:00</span>
        </div>
        {{!-- El panel de jugadores y chat se mover√° aqu√≠ con JS --}}
      </aside>

      {{!-- Panel del Oponente (Derecha) --}}
      <section class="game-enfrentamiento card">
        <h2 id="nombre-oponente">Esperando...</h2>
        <div class="status panel">
          <div>
            <div class="small">Progreso</div>
            <div id="progressText-oponente"><strong>0</strong>/<strong id="totalWords-oponente">0</strong> palabras</div>
          </div>
          <div class="badge" id="errorsBadge-oponente">0 / 4</div>
        </div>
        <div id="board-oponente" class="board"></div>
        <div id="message-oponente" class="message"></div>
        <ul id="clues-oponente" class="clues"></ul>
      </section>
    </div>

    {{!-- Elementos Comunes (se mover√°n con JS a su lugar) --}}
    <div id="elementos-comunes" style="display: none;">
      <div class="panel card" id="jugadores-panel">
        <h3>üü¢ Jugadores activos</h3>
        <ul id="lista-jugadores"></ul>
      </div>
      <div class="panel card" id="chat-panel">
        <h3>üí¨ Chat</h3>
        <div id="chatBox"></div>
        <div class="chat-input">
          <input id="chatInput" type="text" placeholder="Escribe un mensaje‚Ä¶">
          <button id="chatBtn" class="chat-send">Enviar</button>
        </div>
      </div>
      <div class="panel card" id="panel-votacion-enfrentamiento" style="display: none;">
          <h3>üó≥Ô∏è Selecci√≥n de Categor√≠a</h3>
          <div id="propuesta-actual">
              <p>Esperando que un jugador proponga una categor√≠a...</p>
          </div>
          <div id="area-proponer" style="display: none;">
              <label for="categoria-enfrentamiento-select">Elige una categor√≠a:</label>
              <select id="categoria-enfrentamiento-select"><option>Cargando...</option></select>
              <button id="proponer-btn">Proponer</button>
          </div>
          <div id="area-votar" style="display: none;">
              <button id="aceptar-btn">‚úÖ Aceptar</button>
              <button id="rechazar-btn">‚ùå Rechazar</button>
          </div>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // ================== CONFIGURACI√ìN INICIAL ==================
    const ROWS = 10;
    const COLS = 10;
    const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const MAX_ERRORS = 4;
    let WORDS = []; // Se cargar√°n din√°micamente seg√∫n categor√≠a

    // Variables de estado del juego
    let grid = [];
    let cellEls = [];
    let foundWords = new Set();
    let errors = 0;
    let isDragging = false;
    let start = null;
    let dir = null;
    let dragPath = [];

    // Elementos del DOM
    const boardEl = document.getElementById('board');
    const cluesEl = document.getElementById('clues');
    const errorsBadge = document.getElementById('errorsBadge');
    const gameMessage = document.getElementById('gameMessage');
    const btnClear = document.getElementById('btnClear');
    const btnRestart = document.getElementById('btnRestart');
    const totalWords = document.getElementById('totalWords');
    const progressText = document.getElementById('progressText');
    const categoriaSelect = document.getElementById('categoria-select');

    // ================== SISTEMA DE CHAT Y SALA ==================
    const socket = io();
    const salaId = "{{salaId}}";
    const usuario = {{{json user}}};
    const chatBox = document.getElementById('chatBox');
    const chatInput = document.getElementById('chatInput');
    const chatBtn = document.getElementById('chatBtn');
    const listaJugadoresEl = document.getElementById('lista-jugadores');

    // Detectar modo de juego
    const urlParams = new URLSearchParams(window.location.search);
    const modo = urlParams.get('modo') === 'enfrentamiento' ? 'enfrentamiento' : 'cooperativo';
    
    // Configurar vista seg√∫n modo
    if (modo === 'enfrentamiento') {
      document.getElementById('vista-cooperativo').style.display = 'none';
      document.getElementById('vista-enfrentamiento').style.display = 'grid';
      // Mover paneles al centro
      document.getElementById('panel-central-enfrentamiento').appendChild(document.getElementById('jugadores-panel'));
      document.getElementById('panel-central-enfrentamiento').appendChild(document.getElementById('chat-panel'));
      document.getElementById('panel-central-enfrentamiento').appendChild(document.getElementById('panel-votacion-enfrentamiento'));
    }

    // Funci√≥n para mostrar mensajes en el chat
    function mostrarMensaje(user, msg) {
      const msgDiv = document.createElement('div');
      msgDiv.className = 'msg';
      msgDiv.innerHTML = `<span class="u">${user}:</span> <span>${msg}</span>`;
      chatBox.appendChild(msgDiv);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    // Funci√≥n para enviar mensajes
    function enviarMensaje() {
      const mensaje = chatInput.value.trim();
      if (mensaje && salaId) {
        socket.emit('mensajeChat', { salaId, mensaje, usuario: usuario.username });
        chatInput.value = '';
      }
    }

    // Event listeners para el chat
    chatBtn.addEventListener('click', enviarMensaje);
    chatInput.addEventListener('keypress', (e) => e.key === 'Enter' && enviarMensaje());

    // Manejo de mensajes entrantes del socket
    socket.on('nuevoMensaje', (data) => {
      if (data.usuario && data.mensaje) mostrarMensaje(data.usuario, data.mensaje);
    });

    // ================== SISTEMA DE INVITACIONES ==================
    async function cargarJugadoresActivos() {
      try {
        const res = await fetch('/competitivo');
        const jugadores = await res.json();
        listaJugadoresEl.innerHTML = '';
        
        jugadores.forEach(jugador => {
          if (jugador.id === usuario.id_usuario) return;
          const item = document.createElement('li');
          item.innerHTML = `
            <span>${jugador.username}</span>
            <div class="actions">
              <button class="btn-invite" data-id="${jugador.id}">Invitar ü§ù</button>
              <button class="btn-challenge" data-id="${jugador.id}">Enfrentar ‚öîÔ∏è</button>
            </div>
          `;
          listaJugadoresEl.appendChild(item);
        });
      } catch (error) { 
        console.error('Error al cargar jugadores:', error);
        mostrarMensaje('Sistema', 'Error al cargar lista de jugadores');
      }
    }

    // Manejo de clics en botones de invitaci√≥n
    listaJugadoresEl.addEventListener('click', async (e) => {
      const target = e.target;
      const idJugador = target.dataset.id;
      if (!idJugador) return;
      
      try {
        if (target.classList.contains('btn-invite')) {
          const response = await fetch(`/invitar_sop/${idJugador}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ salaId: salaId, juego: 'sopa' })
          });
          const data = await response.json();
          mostrarMensaje('Sistema', data.message || 'Invitaci√≥n enviada');
        } else if (target.classList.contains('btn-challenge')) {
          const response = await fetch(`/enfrentar_so/${idJugador}`, { 
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ juego: 'sopa' })
          });
          const data = await response.json();
          if (data.salaId) {
            mostrarMensaje('Sistema', '¬°Desaf√≠o enviado! Redirigiendo...');
            setTimeout(() => {
              window.location.href = `/sopa/${data.salaId}?modo=enfrentamiento`;
            }, 1500);
          } else {
            mostrarMensaje('Sistema', data.message || 'Error al desafiar');
          }
        }
      } catch (error) {
        console.error('Error en acci√≥n de jugador:', error);
        mostrarMensaje('Sistema', 'Error al procesar la solicitud');
      }
    });

    // ================== L√ìGICA DEL JUEGO ==================
    // Funciones utilitarias
    const inBounds = (r,c) => r>=0 && c>=0 && r<ROWS && c<COLS;
    const randInt = n => Math.floor(Math.random()*n);
    
    const directions = [
      { dr: 0,  dc: 1 },    // ‚Üí
      { dr: 0,  dc: -1 },   // ‚Üê
      { dr: 1,  dc: 0 },    // ‚Üì
      { dr: -1, dc: 0 },    // ‚Üë
      { dr: 1,  dc: 1 },    // diagonal ‚Üì‚Üí
      { dr: 1,  dc: -1 },   // diagonal ‚Üì‚Üê
      { dr: -1, dc: 1 },    // diagonal ‚Üë‚Üí
      { dr: -1, dc: -1 },   // diagonal ‚Üë‚Üê
    ];

    function emptyGrid() {
      grid = Array.from({length: ROWS}, () => Array(COLS).fill(""));
    }

    function canPlace(word, r, c, dr, dc) {
      for (let i=0; i<word.length; i++){
        const rr = r + dr*i, cc = c + dc*i;
        if (!inBounds(rr,cc)) return false;
        const cell = grid[rr][cc];
        if (cell !== "" && cell !== word[i]) return false;
      }
      return true;
    }

    function placeWord(word) {
      const tries = 300;
      for (let t=0; t<tries; t++){
        const {dr,dc} = directions[randInt(directions.length)];
        const startR = randInt(ROWS);
        const startC = randInt(COLS);
        if (canPlace(word, startR, startC, dr, dc)) {
          for (let i=0; i<word.length; i++){
            grid[startR + dr*i][startC + dc*i] = word[i];
          }
          return true;
        }
      }
      return false;
    }

    function fillRandom() {
      for (let r=0; r<ROWS; r++){
        for (let c=0; c<COLS; c++){
          if (grid[r][c]==="") grid[r][c] = ALPHABET[randInt(ALPHABET.length)];
        }
      }
    }

    function renderBoard(boardElement, gridData) {
      boardElement.innerHTML = "";
      const cellElements = Array.from({length: ROWS}, () => Array(COLS));
      for (let r=0; r<ROWS; r++){
        for (let c=0; c<COLS; c++){
          const d = document.createElement('button');
          d.className = 'cell'; d.type = 'button';
          d.textContent = gridData[r][c];
          d.dataset.r = r; d.dataset.c = c;

          // Selecci√≥n por arrastre
          d.addEventListener('mousedown', (e) => {
            if (d.classList.contains('found')) return;
            e.preventDefault();
            startDrag(r, c);
          });
          d.addEventListener('mouseenter', () => {
            if (!isDragging) return;
            continueDrag(r, c);
          });

          boardElement.appendChild(d);
          cellElements[r][c] = d;
        }
      }

      // Global: terminar al soltar
      document.addEventListener('mouseup', endDrag);
      // Evitar que el navegador arrastre textos
      boardElement.addEventListener('dragstart', e => e.preventDefault());
      
      return cellElements;
    }

    function renderClues(cluesElement, words, foundWordsSet) {
      cluesElement.innerHTML = "";
      words.forEach(({word, hint}) => {
        const li = document.createElement('li');
        li.id = `clue-${word}`;
        li.classList.toggle('done', foundWordsSet.has(word));
        li.innerHTML = `<div class="word">${word}</div><div class="hint">${hint}</div>`;
        cluesElement.appendChild(li);
      });
    }

    function updateProgress(progressElement, totalElement, foundCount, totalCount) {
      progressElement.innerHTML = `<strong>${foundCount}</strong>/<strong>${totalCount}</strong> palabras`;
      totalElement.textContent = totalCount;
    }

    function setErrors(errorsBadgeElement, errorCount) {
      errorsBadgeElement.textContent = `${errorCount} / ${MAX_ERRORS}`;
      errorsBadgeElement.style.background = errorCount ? '#fee2e2' : '#e5e7eb';
    }

    function showMessage(messageElement, text, kind='') {
      messageElement.className = `message ${kind}`;
      messageElement.textContent = text;
    }

    // Manejo de selecci√≥n por arrastre
    function clearPathVisual() {
      dragPath.forEach(p => p.el.classList.remove('selected'));
    }

    function startDrag(r, c) {
      isDragging = true;
      start = { r, c };
      dir = null;
      clearPathVisual();
      dragPath = [];

      const el = cellEls[r][c];
      if (el.classList.contains('found')) return;
      el.classList.add('selected');
      dragPath.push({ r, c, el, letter: el.textContent });
      
      if (modo === 'cooperativo') {
        showMessage(gameMessage, "");
      }
    }

    function continueDrag(r, c) {
      if (!isDragging || !start) return;

      const drRaw = r - start.r;
      const dcRaw = c - start.c;

      // Si no hay movimiento, salir
      if (drRaw === 0 && dcRaw === 0) return;

      // fijar direcci√≥n (dr, dc) como el paso unitario de la l√≠nea recta
      if (!dir) {
          const stepR = drRaw === 0 ? 0 : drRaw / Math.abs(drRaw);
          const stepC = dcRaw === 0 ? 0 : dcRaw / Math.abs(dcRaw);
          dir = { dr: stepR, dc: stepC };
      }

      // comprobar que la celda est√° en la misma l√≠nea recta seg√∫n dir
      const expectedSteps = Math.max(
          dir.dr !== 0 ? (r - start.r)/dir.dr : 0,
          dir.dc !== 0 ? (c - start.c)/dir.dc : 0
      );
      if (!Number.isInteger(expectedSteps) || expectedSteps < 0) return;

      // construir el camino desde start hasta (r,c)
      const length = expectedSteps + 1;
      const maxLen = Math.max(...WORDS.map(w => w.word.length));
      const cappedLen = Math.min(length, maxLen);

      const newPath = [];
      for (let i = 0; i < cappedLen; i++) {
          const rr = start.r + dir.dr * i;
          const cc = start.c + dir.dc * i;
          if (!inBounds(rr, cc)) break;
          const el = cellEls[rr][cc];
          if (el.classList.contains('found')) break;
          newPath.push({ r: rr, c: cc, el, letter: el.textContent });
      }

      clearPathVisual();
      dragPath = newPath;
      dragPath.forEach(p => p.el.classList.add('selected'));
    }

    function endDrag() {
      if (!isDragging) return;
      isDragging = false;
      validateDrag();
      start = null;
      dir = null;
    }

    function validateDrag() {
      const text = dragPath.map(p => p.letter).join("");
      clearPathVisual();

      if (!text) return;

      const remaining = WORDS.filter(w => !foundWords.has(w.word));
      const exact = remaining.find(w => w.word === text || w.word === [...text].reverse().join(""));

      if (exact) {
        // fijar como encontrada
        dragPath.forEach(p => p.el.classList.add('found'));
        foundWords.add(exact.word);
        
        if (modo === 'cooperativo') {
          renderClues(cluesEl, WORDS, foundWords);
          updateProgress(progressText, totalWords, foundWords.size, WORDS.length);
          showMessage(gameMessage, `¬°Encontraste "${exact.word}"! üéâ`, 'win');

          if (foundWords.size === WORDS.length) {
            showMessage(gameMessage, "ü•≥ ¬°Ganaste! Has encontrado todas las palabras.", 'win');
          }
          
          // Enviar al servidor en modo cooperativo
          socket.emit('sopa:palabraEncontrada', { salaId, palabra: exact.word, usuario: usuario.username });
        }
      } else {
        errors++;
        setErrors(errorsBadge, errors);
        
        if (modo === 'cooperativo') {
          showMessage(gameMessage, `‚ùå Selecci√≥n incorrecta. Te quedan ${MAX_ERRORS - errors} intentos.`, 'lose');
          
          if (errors >= MAX_ERRORS) {
            showMessage(gameMessage, "üí• ¬°Perdiste! Reiniciando la sopa‚Ä¶", 'lose');
            setTimeout(initGame, 1100);
          }
        }
      }

      dragPath = [];
    }

    // ================== CONTROL DEL JUEGO ==================
    async function cargarCategorias(selectElement) {
      try {
        const response = await fetch('/sopa/materias');
        if (!response.ok) throw new Error('No se pudieron cargar categor√≠as');
        const materias = await response.json();
        
        selectElement.innerHTML = '';
        materias.forEach(materia => {
          const option = document.createElement('option');
          option.value = materia.id_materia;
          option.textContent = materia.descripcion;
          selectElement.appendChild(option);
        });
      } catch (error) {
        console.error("Error al cargar categor√≠as:", error);
        selectElement.innerHTML = '<option>Error al cargar categor√≠as</option>';
      }
    }

    async function cargarPalabrasPorCategoria(idMateria) {
      try {
        const response = await fetch(`/sopa/palabras/${idMateria}`);
        if (!response.ok) throw new Error('Error al cargar palabras');
        return await response.json();
      } catch (error) {
        console.error("Error al cargar palabras:", error);
        return [];
      }
    }

    async function initGame() {
      const idMateria = categoriaSelect.value || 1;
      WORDS = await cargarPalabrasPorCategoria(idMateria);
      
      if (WORDS.length === 0) {
        WORDS = [
          { word: "ERROR", hint: "No se pudieron cargar palabras" },
          { word: "CARGA", hint: "Intenta recargar la p√°gina" }
        ];
      }

      if (modo === 'cooperativo') {
        showMessage(gameMessage, "");
        setErrors(errorsBadge, 0);
      }
      
      foundWords.clear();
      dragPath = [];
      start = null; dir = null;

      // Generar tablero
      for (let safety=0; safety<60; safety++){
        emptyGrid();
        let ok = true;
        for (const {word} of WORDS) {
          if (!placeWord(word)) { ok = false; break; }
        }
        if (ok) break;
      }
      fillRandom();
      
      if (modo === 'cooperativo') {
        cellEls = renderBoard(boardEl, grid);
        renderClues(cluesEl, WORDS, foundWords);
        updateProgress(progressText, totalWords, foundWords.size, WORDS.length);
      }
    }

    // ================== EVENT LISTENERS ==================
    btnClear.addEventListener('click', () => {
      clearPathVisual();
      dragPath = [];
      start = null; dir = null;
      if (modo === 'cooperativo') {
        showMessage(gameMessage, "");
      }
    });

    btnRestart.addEventListener('click', initGame);
    categoriaSelect.addEventListener('change', initGame);

    // ================== INICIALIZACI√ìN ==================
    document.addEventListener('DOMContentLoaded', async () => {
      // Configurar chat
      socket.emit('unirseSala', { salaId, usuario: usuario.username });
      mostrarMensaje('Sistema', `Bienvenido a la sala ${salaId}`);
      
      // Cargar datos iniciales
      await cargarCategorias(categoriaSelect);
      
      if (modo === 'cooperativo') {
        await initGame();
      } else {
        // Modo enfrentamiento - inicializar l√≥gica espec√≠fica
        socket.emit('sopa:unirseEnfrentamiento', { salaId, usuario: usuario.username, userId: usuario.id_usuario });
        
        // Cargar categor√≠as para el panel de votaci√≥n
        await cargarCategorias(document.getElementById('categoria-enfrentamiento-select'));
      }
      
      await cargarJugadoresActivos();
      
      // Actualizar lista de jugadores peri√≥dicamente
      setInterval(cargarJugadoresActivos, 15000);
    });

    // ================== L√ìGICA ESPEC√çFICA PARA MODO ENFRENTAMIENTO ==================
    if (modo === 'enfrentamiento') {
      // Elementos del modo enfrentamiento
      const timerEl = document.getElementById('timer');
      const progressTextLocal = document.getElementById('progressText-local');
      const totalWordsLocal = document.getElementById('totalWords-local');
      const errorsBadgeLocal = document.getElementById('errorsBadge-local');
      const messageLocal = document.getElementById('message-local');
      const boardLocal = document.getElementById('board-local');
      const cluesLocal = document.getElementById('clues-local');
      
      const progressTextOponente = document.getElementById('progressText-oponente');
      const totalWordsOponente = document.getElementById('totalWords-oponente');
      const errorsBadgeOponente = document.getElementById('errorsBadge-oponente');
      const messageOponente = document.getElementById('message-oponente');
      const boardOponente = document.getElementById('board-oponente');
      const cluesOponente = document.getElementById('clues-oponente');
      
      const nombreOponenteEl = document.getElementById('nombre-oponente');
      const panelVotacion = document.getElementById('panel-votacion-enfrentamiento');
      const propuestaActualDiv = document.getElementById('propuesta-actual');
      const areaProponerDiv = document.getElementById('area-proponer');
      const areaVotarDiv = document.getElementById('area-votar');
      const categoriaEnfrentamientoSelect = document.getElementById('categoria-enfrentamiento-select');
      const proponerBtn = document.getElementById('proponer-btn');
      const aceptarBtn = document.getElementById('aceptar-btn');
      const rechazarBtn = document.getElementById('rechazar-btn');

      let timerInterval = null;
      let gameState = null;

      // Funci√≥n para iniciar el temporizador
      function startTimer(initialTime) {
        if (timerInterval) clearInterval(timerInterval);
        
        let timeLeft = initialTime;
        timerInterval = setInterval(() => {
          timeLeft--;
          if (timeLeft < 0) {
            clearInterval(timerInterval);
            // El tiempo se acab√≥, terminar juego
            socket.emit('sopa:tiempoAgotado', { salaId });
            return;
          }
          const minutes = Math.floor(timeLeft / 60).toString().padStart(2, '0');
          const seconds = (timeLeft % 60).toString().padStart(2, '0');
          timerEl.textContent = `${minutes}:${seconds}`;
        }, 1000);
      }

      // Eventos de sockets para modo enfrentamiento
      socket.on('sopa:esperandoOponente', () => {
        panelVotacion.style.display = 'block';
        propuestaActualDiv.innerHTML = `<p>Esperando a tu oponente...</p>`;
        areaProponerDiv.style.display = 'none';
        areaVotarDiv.style.display = 'none';
      });

      socket.on('sopa:iniciarVotacion', () => {
        panelVotacion.style.display = 'block';
        propuestaActualDiv.innerHTML = `<p>¬°Oponente conectado! Por favor, propone una categor√≠a.</p>`;
        areaProponerDiv.style.display = 'block';
        areaVotarDiv.style.display = 'none';
      });

      socket.on('sopa:nuevaPropuesta', ({ proponente, textoMateria }) => {
        panelVotacion.style.display = 'block';
        propuestaActualDiv.innerHTML = `<p><strong>${proponente}</strong> ha propuesto: <strong>${textoMateria}</strong></p>`;
        areaProponerDiv.style.display = 'none';
        // Si el usuario actual NO es el proponente, muestra los botones de votar
        if (proponente !== usuario.username) {
          areaVotarDiv.style.display = 'block';
        }
      });
      
      socket.on('sopa:propuestaRechazada', ({ votante }) => {
        alert(`${votante} ha rechazado la propuesta. ¬°Vuelvan a proponer!`);
        propuestaActualDiv.innerHTML = `<p>Propuesta rechazada. Esperando nueva propuesta...</p>`;
        areaVotarDiv.style.display = 'none';
      });

      socket.on('sopa:estadoEnfrentamiento', (estado) => {
        gameState = estado;
        
        // Ocultar panel de votaci√≥n y mostrar juego
        panelVotacion.style.display = 'none';
        
        // Actualizar informaci√≥n del jugador local
        const jugadorLocal = estado.jugador1.id === usuario.id_usuario ? estado.jugador1 : estado.jugador2;
        const oponente = estado.jugador1.id === usuario.id_usuario ? estado.jugador2 : estado.jugador1;
        
        // Actualizar oponente
        nombreOponenteEl.textContent = oponente.username;
        updateProgress(progressTextOponente, totalWordsOponente, oponente.palabrasEncontradas.length, estado.palabras.length);
        setErrors(errorsBadgeOponente, oponente.errores);
        renderClues(cluesOponente, estado.palabras, new Set(oponente.palabrasEncontradas));
        
        // Actualizar jugador local
        updateProgress(progressTextLocal, totalWordsLocal, jugadorLocal.palabrasEncontradas.length, estado.palabras.length);
        setErrors(errorsBadgeLocal, jugadorLocal.errores);
        renderClues(cluesLocal, estado.palabras, new Set(jugadorLocal.palabrasEncontradas));
        
        // Renderizar tableros
        if (jugadorLocal.tablero) {
          cellEls = renderBoard(boardLocal, jugadorLocal.tablero);
        }
        
        if (oponente.tablero) {
          renderBoard(boardOponente, oponente.tablero);
        }
        
        // Iniciar temporizador si es necesario
        if (estado.tiempoRestante && !timerInterval) {
          startTimer(estado.tiempoRestante);
        }
      });

      socket.on('sopa:palabraEncontradaEnfrentamiento', ({ jugadorId, palabra }) => {
        if (jugadorId === usuario.id_usuario) {
          showMessage(messageLocal, `¬°Encontraste "${palabra}"! üéâ`, 'win');
        } else {
          showMessage(messageOponente, `¬°Encontr√≥ "${palabra}"!`, 'win');
        }
      });

      socket.on('sopa:errorEnfrentamiento', ({ jugadorId }) => {
        if (jugadorId === usuario.id_usuario) {
          showMessage(messageLocal, `‚ùå Selecci√≥n incorrecta`, 'lose');
        }
      });

      socket.on('sopa:finEnfrentamiento', ({ ganadorId }) => {
        if (timerInterval) clearInterval(timerInterval);
        
        if (ganadorId === usuario.id_usuario) {
          showMessage(messageLocal, "ü•≥ ¬°Ganaste la partida!", 'win');
        } else if (ganadorId) {
          showMessage(messageLocal, "üò¢ Perdiste la partida", 'lose');
        } else {
          showMessage(messageLocal, "ü§ù Empate", '');
        }
      });

      // Event listeners para los botones de votaci√≥n
      proponerBtn.onclick = () => {
        const select = categoriaEnfrentamientoSelect;
        const idMateria = select.value;
        const textoMateria = select.options[select.selectedIndex].text;
        socket.emit('sopa:proponerCategoria', { salaId, idMateria, textoMateria });
        propuestaActualDiv.innerHTML = `<p>Has propuesto: <strong>${textoMateria}</strong>. Esperando respuesta...</p>`;
        areaProponerDiv.style.display = 'none';
      };

      aceptarBtn.onclick = () => {
        socket.emit('sopa:votarCategoria', { salaId, voto: 'aceptado' });
        areaVotarDiv.style.display = 'none';
      };

      rechazarBtn.onclick = () => {
        socket.emit('sopa:votarCategoria', { salaId, voto: 'rechazado' });
        areaVotarDiv.style.display = 'none';
      };
    }
  </script>
</body>
</html>